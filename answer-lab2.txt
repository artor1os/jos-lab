1. x是uintptr_t, 内核只能对虚拟地址解引用，代码中对value进行解引用，所以value一定是一个虚拟地址，x和value值相同。
2.
    960-1023，0xf0000000-0xffffffff，物理内存映射
    959，0xefc00000，内核栈
    957，0xef400000，内核页表
    956，0xef000000，物理页
3.内核内存的PTE的user位都设为0，用户程序CPL为3，若想访问内核内存必须经过MMU，MMU检查权限位发现权限等级不够，
拒绝用户访问。
4.256MB，供物理内存映射的地址空间是0xf0000000到0xffffffff，所以最多支持0x10000000 bytes的物理内存，即256MB。
5.1级页表一个加上2级页表1024个，单个页表大小为4KB，所以总大小约为4MB。
6.jmp指令后eip跳到KERNBASE以上，在高低地址都能运行是因为实际物理地址并没有变，这两个虚拟地址都指向同一个物理地址。
因为c代码的链接地址是从KERNBASE开始算的，而内核实际加载地址是从物理地址0开始算的1MB的地方，所以要建立一个简单的页
表把物理地址0映射到虚拟地址KERNBASE上，才能运行c代码。

challenge:

第一个。
大页机制下，虚拟地址的前10个bit作为页表项的索引，而不是页目录的索引，也就是只有一级页表，所以需修改
boot_map_region_large函数，使其用虚拟地址的前10个bit作为页表项的索引写入页表项，同时页表项的PTE_PS需置上。
另外需要将cr4寄存器的CR4_PSE位置上，打开大页功能。
